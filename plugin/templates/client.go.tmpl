// Package adapter contains auto-generated gRPC client
// Generated from protobuf annotations - DO NOT EDIT
package adapter

import (
{{- range .PackageImports }}
	"{{.}}"
{{- end }}
{{- if .ProtobufPackage }}
	{{.ProtobufAlias}} "{{.ProtobufPackage}}"
{{- end }}
	"google.golang.org/grpc"
)

{{- range .Services }}
{{- $serviceName := .Name }}
// {{.Name}}Client wraps the gRPC client and provides Go types interface
type {{.Name}}Client struct {
	client {{$.ProtobufAlias}}.{{.Name}}Client
}

// New{{.Name}}Client creates a new client for the service
func New{{.Name}}Client(conn *grpc.ClientConn) *{{.Name}}Client {
	return &{{.Name}}Client{
		client: {{$.ProtobufAlias}}.New{{.Name}}Client(conn),
	}
}

{{- range .Methods }}
{{- if not .IsStreaming }}
// {{.Name}} calls the gRPC {{.Name}} method using Go types
{{- if eq .OriginalOutputType "error" }}
func (c *{{$serviceName}}Client) {{.Name}}({{if ne .OriginalInputType ""}}req {{.OriginalInputType}}{{end}}) error {
{{- else }}
func (c *{{$serviceName}}Client) {{.Name}}({{if ne .OriginalInputType ""}}req {{.OriginalInputType}}{{end}}) ({{.OriginalOutputType}}, error) {
{{- end }}
{{- if eq .InputType "google.protobuf.Empty" }}
	// Call gRPC method with empty request
	{{- if eq .OriginalOutputType "error" }}
	_, err := c.client.{{.Name}}(context.Background(), &emptypb.Empty{})
	{{- else }}
	protoResp, err := c.client.{{.Name}}(context.Background(), &emptypb.Empty{})
	{{- end }}
{{- else if hasPrefix .InputType "google.protobuf." }}
	// Convert primitive to wrapper
{{- if eq .InputType "google.protobuf.Int64Value" }}
	protoReq := &wrapperspb.Int64Value{Value: req}
{{- else if eq .InputType "google.protobuf.StringValue" }}
	protoReq := &wrapperspb.StringValue{Value: req}
{{- else if eq .InputType "google.protobuf.BoolValue" }}
	protoReq := &wrapperspb.BoolValue{Value: req}
{{- else if eq .InputType "google.protobuf.DoubleValue" }}
	protoReq := &wrapperspb.DoubleValue{Value: req}
{{- else if eq .InputType "google.protobuf.FloatValue" }}
	protoReq := &wrapperspb.FloatValue{Value: req}
{{- else if eq .InputType "google.protobuf.UInt64Value" }}
	protoReq := &wrapperspb.UInt64Value{Value: req}
{{- else if eq .InputType "google.protobuf.UInt32Value" }}
	protoReq := &wrapperspb.UInt32Value{Value: req}
{{- else if eq .InputType "google.protobuf.Int32Value" }}
	protoReq := &wrapperspb.Int32Value{Value: req}
{{- else if eq .InputType "google.protobuf.BytesValue" }}
	protoReq := &wrapperspb.BytesValue{Value: req}
{{- else }}
	{{- if hasPrefix .OriginalInputType "*" }}
	protoReq := {{.InputType}}ToProto(*req)
	{{- else }}
	protoReq := {{.InputType}}ToProto(req)
	{{- end }}
{{- end }}

	// Call gRPC method
	{{- if eq .OriginalOutputType "error" }}
	_, err := c.client.{{.Name}}(context.Background(), protoReq)
	{{- else }}
	protoResp, err := c.client.{{.Name}}(context.Background(), protoReq)
	{{- end }}
{{- else }}
	// Convert Go request to protobuf
	{{- if hasPrefix .OriginalInputType "*" }}
	protoReq := {{.InputType}}ToProto(*req)
	{{- else }}
	protoReq := {{.InputType}}ToProto(req)
	{{- end }}

	// Call gRPC method
	{{- if eq .OriginalOutputType "error" }}
	_, err := c.client.{{.Name}}(context.Background(), protoReq)
	{{- else }}
	protoResp, err := c.client.{{.Name}}(context.Background(), protoReq)
	{{- end }}
{{- end }}
	if err != nil {
{{- if eq .OriginalOutputType "error" }}
		return err
{{- else }}
		return {{zeroValue .OriginalOutputType}}, err
{{- end }}
	}

{{- if eq .OutputType "google.protobuf.Empty" }}
	return nil
{{- else if hasPrefix .OutputType "google.protobuf." }}
	// Extract value from wrapper
{{- if eq .OutputType "google.protobuf.Int64Value" }}
	return protoResp.Value, nil
{{- else if eq .OutputType "google.protobuf.StringValue" }}
	return protoResp.Value, nil
{{- else if eq .OutputType "google.protobuf.BoolValue" }}
	return protoResp.Value, nil
{{- else if eq .OutputType "google.protobuf.DoubleValue" }}
	return protoResp.Value, nil
{{- else if eq .OutputType "google.protobuf.FloatValue" }}
	return protoResp.Value, nil
{{- else if eq .OutputType "google.protobuf.UInt64Value" }}
	return protoResp.Value, nil
{{- else if eq .OutputType "google.protobuf.UInt32Value" }}
	return protoResp.Value, nil
{{- else if eq .OutputType "google.protobuf.Int32Value" }}
	return protoResp.Value, nil
{{- else if eq .OutputType "google.protobuf.BytesValue" }}
	return protoResp.Value, nil
{{- else }}
	{{- if hasPrefix .OriginalOutputType "*" }}
	result := {{.OutputType}}FromProto(protoResp)
	return &result, nil
	{{- else }}
	return {{.OutputType}}FromProto(protoResp), nil
	{{- end }}
{{- end }}
{{- else }}
	// Convert protobuf response back to Go types
	{{- if hasPrefix .OriginalOutputType "*" }}
	result := {{.OutputType}}FromProto(protoResp)
	return &result, nil
	{{- else }}
	return {{.OutputType}}FromProto(protoResp), nil
	{{- end }}
{{- end }}
}
{{- else if and (not .ClientStream) .ServerStream }}
// {{.Name}} calls the gRPC {{.Name}} streaming method
func (c *{{$serviceName}}Client) {{.Name}}(ctx context.Context, req models.{{.InputType}}) (chan models.{{.OutputType}}, error) {
	// Convert Go request to protobuf
	protoReq := {{.InputType}}ToProto(req)

	// Call gRPC streaming method
	stream, err := c.client.{{.Name}}(ctx, protoReq)
	if err != nil {
		return nil, err
	}

	// Create output channel
	resultChan := make(chan models.{{.OutputType}}, 100)

	// Start goroutine to read from stream
	go func() {
		defer close(resultChan)
		for {
			resp, err := stream.Recv()
			if err == io.EOF {
				break
			}
			if err != nil {
				// Log error and close channel gracefully
				log.Printf("Error receiving from stream: %v", err)
				return
			}
			resultChan <- {{.OutputType}}FromProto(resp)
		}
	}()

	return resultChan, nil
}
{{- else if and .ClientStream (not .ServerStream) }}
// {{.Name}} calls the gRPC {{.Name}} client streaming method
func (c *{{$serviceName}}Client) {{.Name}}(ctx context.Context, inputChan chan models.{{.InputType}}) (models.{{.OutputType}}, error) {
	// Call gRPC streaming method
	stream, err := c.client.{{.Name}}(ctx)
	if err != nil {
		return models.{{.OutputType}}{}, err
	}

	// Send data from input channel in goroutine and wait for completion
	sendDone := make(chan error, 1)
	go func() {
		defer stream.CloseSend()
		for input := range inputChan {
			protoReq := {{.InputType}}ToProto(input)
			if err := stream.Send(protoReq); err != nil {
				sendDone <- err
				return
			}
		}
		sendDone <- nil
	}()

	// Wait for sending to complete or timeout
	select {
	case err := <-sendDone:
		if err != nil {
			return models.{{.OutputType}}{}, err
		}
	case <-ctx.Done():
		return models.{{.OutputType}}{}, ctx.Err()
	}

	// Receive final response
	protoResp, err := stream.CloseAndRecv()
	if err != nil {
		return models.{{.OutputType}}{}, err
	}

	return {{.OutputType}}FromProto(protoResp), nil
}
{{- else }}
// {{.Name}} calls the gRPC {{.Name}} bidirectional streaming method
func (c *{{$serviceName}}Client) {{.Name}}(ctx context.Context, inputChan chan models.{{.InputType}}) (chan models.{{.OutputType}}, error) {
	// Call gRPC streaming method
	stream, err := c.client.{{.Name}}(ctx)
	if err != nil {
		return nil, err
	}

	// Create output channel
	resultChan := make(chan models.{{.OutputType}}, 100)

	// Start goroutine to send data
	go func() {
		defer stream.CloseSend()
		for input := range inputChan {
			protoReq := {{.InputType}}ToProto(input)
			if err := stream.Send(protoReq); err != nil {
				// Log error and stop sending
				log.Printf("Error sending to bidirectional stream: %v", err)
				return
			}
		}
	}()

	// Start goroutine to receive data
	go func() {
		defer close(resultChan)
		for {
			resp, err := stream.Recv()
			if err == io.EOF {
				break
			}
			if err != nil {
				// Log error and close channel gracefully
				log.Printf("Error receiving from bidirectional stream: %v", err)
				return
			}
			resultChan <- {{.OutputType}}FromProto(resp)
		}
	}()

	return resultChan, nil
}
{{- end }}
{{- end }}
{{- end }}